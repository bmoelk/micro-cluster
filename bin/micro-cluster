#!/usr/bin/env node

import program from 'commander'
import { parse as parseUrl } from 'url'
import { dirname, resolve } from 'path'
import { spawn } from 'mz/child_process'
import micro from 'micro-core'
import { createProxyServer } from 'http-proxy'
import getPort from 'get-port'
import babelRegister from 'babel-register'
import presetES2015 from 'babel-preset-es2015'
import transformAsyncToGenerator from 'babel-plugin-transform-async-to-generator'
import { version } from '../../package'

babelRegister({
  presets: [presetES2015],
  plugins: [transformAsyncToGenerator]
})

program
.version(version)
.option('-p, --port <port>', 'Port to listen on (3000)', parseInt)
.parse(process.argv)

const programPort = program.port || 3000
const file = resolve(process.cwd(), program.args[0] || 'app.js')

main()
.catch((err) => {
  process.nextTick(() => {
    throw err
  })
})

async function main () {
  const config = require(file).default
  const services = new Map()

  for (const id of Object.keys(config.services)) {
    let service = config.services[id]
    if ('string' === typeof service) {
      service = { path: service }
    }

    const path = resolve(dirname(file), service.path)
    const env = service.env
      ? Object.assign({}, process.env, service.env) : process.env
    const port = service.port || await getPort()

    const opts = { env, stdio: 'inherit', customFds: [0, 1, 2] }
    await spawn(resolve(__dirname, 'micro'), ['--port', port, path], opts)
    services.set(id, port)
  }

  const proxyServer = createProxyServer()
  const locations = Object.keys(config.locations)
  .map((l) => {
    const location = config.locations[l]
    const rewrite = [
      new RegExp(location.rewrite[0].replace(/\//, '//')),
      ...location.rewrite.slice(1)
    ]
    const match = new RegExp(l.replace(/\//g, '//'))
    return Object.assign({}, location, { rewrite, match })
  })

  micro(async (req, res) => {
    const { pathname, search } = parseUrl(req.url)

    for (const { match, rewrite, proxy } of locations) {
      if (!match.test(pathname)) continue

      const newPathname = pathname.replace.apply(pathname, rewrite)
      const port = services[proxy]

      const target = `http://localhost:${port}${newPathname}${search || ''}`
      proxyServer.web(req, res, { target, ignorePath: true })
      return
    }

    res.writeHead(404)
    res.end('Not found')
  }).listen(programPort, (err) => {
    if (err) {
      console.error(err.stack)
      process.exit(1)
    }

    console.log(`> \u001b[96mReady!\u001b[39m Listening on ${programPort}.`)
  })
}
